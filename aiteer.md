



## aiteer 公司

## 解决的痛点与难点

1. 当数据量大的时候程序会崩溃，并且重启也运行不起来。

   这个的主要原因是这些数据全部都会数据库里面查询，最终导致异步处理超时导致。

   根本原因就是checkpoint 失败，checkpoint 超时多次，最终flink 认定程序异常而结束job。

   从表面上看，我们只需要将checkpoint 的超时时间无限拉长就总能解决这个问题，但是不是有效的解决方案。

   所以这里最终的解决方案就是引入redis 缓存，而实际上在我来之前，他们也已经引入了redis，但却没有得到解决。

   这就很奇葩了，其原因是，引入了redis ，却因为代码功底太过于差劲，最终没有用起来。

   代码里面的太多不好的风格和习惯，导致了这个问题，引入了redis 也写了redis 的相关逻辑，但却是在使用的地方，redis 连接总是null。

   我最终的解决也很简单，就是将redis 正常引入即解决了他们长久以来，所认为遇到的难点与痛点。

2. 通过checkpoint 重新启动不会成功，最终重新开始运行。

   这个的根本原因还是上面redis 缓存没用起来的原因，在启动之后数据重放，显然这个时间 的数据量不少(其实也就一两万条而以)。

   这些数据全部访问mysql，在checkpoint 超时时间内(或者异步处理超时时间内)没有完成，最终失败。

   因为我们使用的是rabbitmq，而没有设置预取数量，所以一次将所有 数据都出来了。最终将该值添加上可以缓解某个时段的问题。

   但最根本的核心解决思路其实还是使用redis 缓存。

3. 在standalone 模式下，每次提交job 都会增加mysql 数据库的连接，只有结束standalone 重新启动连接才会被释放。

   这其实就是一个释放连接资源的问题，这里他们原生的代码总是喜欢使用静态类与静态方法的形式，这显然不好，特别是在flink 下。

   因为flink 的机制问题，我们并不确定哪些算子将在哪个TaskManager 下运行，甚至都不确定他们会不会在同一台机器实例上运行，这跟flink 的算子、任务与子任务的运行机制，JobManager 分配策略有关。

   所以这些地方我们应该使用对象的方式，如果真的需要使用到单例模式，我们还应该要注意使用引用计数来进行资源的初始化与释放问题。

   因为算子的初始化都是相互独立的，前一个算子如果没有数据再次进入那么它就会释放自己所有的资源也就是调用 close() 方法(RichFunction 接口)。

   如果单例资源对象，我们没有使用引用计数来进行资源释放，那就会出现这样的场景。上一个算子结束，释放了mysql 连接。但下一个算子却还在运行，当访问 mysql 连接时，它已经被释放并开连接了，这个时候很显然就会全部失败并导致异常。

4. 引入springboot，简化相关的配置，去除代码 中flink 原生已经支持的配置项。

   代码中很多的对flink 的配置，都通过代码的形式来控制，这其实很不好。因为flink 本身就对这些进行扩展配置，只需要使用对应 的配置项即可，不用写一行代码。

   使用springboot 的配置文件机制代替代码中去实现读文件再解析文件最终拿到配置项的方案。很好的利用了springboot 的优点，而自己维护配置文件是一件很麻烦 的事，而且用法很固化且没有任何一些兼容性的处理，可扩展性可维护性和健壮性都不好。

   使用springboot 来使用redis和mysql 这样大大简化了代码，同时不需要去使用最原生的三方组件来实现相关功能。以及还要自行维护相关连接。

5. 版本升级，在我之前他们一直使用两年前的版本一点没有升级。

6. 流批一体，合并。

7. 其他







